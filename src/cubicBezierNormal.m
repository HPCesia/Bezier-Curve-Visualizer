function func = cubicBezierNormal(points)
dp = points(:, 2:4) - points(:, 1:3);
ddp = dp(:, 2:3) - dp(:, 1:2);
dcx = @(t) (1 - t).^2 .* dp(1, 1) + 2 * (1 - t) .* t .* dp(1, 2) + t.^2 .* dp(1, 3);
ddcx = @(t) 2 * (1 - t) .* ddp(1, 1) + 2 * t .* ddp(1, 2);
dcy = @(t) (1 - t).^2 .* dp(2, 1) + 2 * (1 - t) .* t .* dp(2, 2) + t.^2 .* dp(2, 3);
ddcy = @(t) 2 * (1 - t) .* ddp(2, 1) + 2 * t .* ddp(2, 2);

% cross(c', c'')，使用 mathmatica 按幂合并得到的公式
cross_dcddc = @(t) norm(dp(:, 1))^2 + t * (-4 * norm(dp(:, 1))^2 + 4 * dot(dp(:, 1), dp(:, 2))) + ...
    t.^2 * (6 * norm(dp(:, 1))^2 - 12 * dot(dp(:, 1), dp(:, 2)) + ...
    4 * norm(dp(:, 2))^2 + 2 * dot(dp(:, 1), dp(:, 3))) + ...
    t.^3 * (-4 * norm(dp(:, 1))^2 + 12 * dot(dp(:, 1), dp(:, 2)) - ...
    8 * norm(dp(:, 2))^2 - 4 * dot(dp(:, 1), dp(:, 3)) + 4 * dot(dp(:, 2), dp(:, 3))) + ...
    t.^4 * (norm(dp(:, 1))^2 - 4 * dot(dp(:, 1), dp(:, 2)) + 4 * norm(dp(:, 2))^2 + ...
    2 * dot(dp(:, 1), dp(:, 3)) - 4 * dot(dp(:, 2), dp(:, 3)) + norm(dp(:, 3))^2);

func = @(t) sqrt(dcx(t).^2 + dcy(t).^2) ./ sqrt(cross_dcddc(t)) .* [ddcx(t); ddcy(t)] - ...
    (dcx(t) .* ddcx(t) + dcy(t) .* ddcy(t)) / (sqrt(dcx(t).^2 + dcy(t).^2) .* sqrt(cross_dcddc(t))) .* [dcx(t); dcy(t)];
end
